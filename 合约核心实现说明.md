# Web3教育平台智能合约核心实现说明

## 项目概述

本项目包含三个核心智能合约，构成了一个完整的Web3教育平台生态系统：

1. **YDToken.sol** - 平台代币合约
2. **CourseManager.sol** - 课程管理与代币兑换合约  
3. **StakingSystem.sol** - 基于AAVE的质押收益系统

---

## 1. YDToken - 一灯平台代币

### 合约功能
YDToken是一个基于ERC20标准的平台代币，作为整个教育生态的价值载体。

### 核心代码实现

```solidity
/**
 * @title YDToken - 一灯平台代币
 * @dev 这是一个标准的ERC20代币合约，用作一灯教育平台的主要代币
 * 具备铸造和销毁功能，用于课程购买、质押奖励等场景
 */
contract YDToken is ERC20, Ownable {
    // 初始供应量：10,000个YD代币
    uint256 public constant INITIAL_SUPPLY = 10_000 * 10**18;
    
    constructor(address initialOwner) 
        ERC20("YiDeng Platform Token", "YD") 
        Ownable(initialOwner)
    {
        // 向初始所有者铸造初始供应量的代币
        _mint(initialOwner, INITIAL_SUPPLY);
    }
    
    /**
     * @dev 铸造代币功能 - 仅合约所有者可调用
     */
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
    
    /**
     * @dev 销毁代币功能 - 任何人都可以销毁自己的代币
     */
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
    }
}
```

### 关键特性
- **标准ERC20**: 符合以太坊代币标准，支持转账、授权等基础功能
- **可铸造**: 合约所有者可以根据需要铸造新代币
- **可销毁**: 用户可以销毁自己持有的代币，实现通胀控制
- **初始供应**: 部署时铸造10,000个YD代币给合约所有者

---

## 2. CourseManager - 课程管理与代币兑换

### 合约功能
这是系统的核心合约，集成了课程管理和ETH/YD代币兑换功能。

### 核心数据结构

```solidity
// 课程结构体
struct Course {
    string courseId;    // 课程ID
    string title;       // 课程标题
    string description; // 课程描述
    uint256 price;      // 课程价格（YD代币）
    address creator;    // 课程创建者地址
    bool isActive;      // 课程是否激活
    uint256 createdAt;  // 创建时间戳
}

// 常量配置
uint256 public constant FEE_RATE = 500;        // 平台手续费率：5%
uint256 public constant EXCHANGE_RATE = 4000;  // 兑换汇率：1 ETH = 4000 YD
```

### 课程管理核心功能

```solidity
/**
 * @dev 创建新课程
 */
function createCourse(
    string memory courseId,
    string memory title,
    string memory description,
    uint256 price
) external {
    require(bytes(courseId).length > 0, "Course ID cannot be empty");
    require(bytes(title).length > 0, "Title cannot be empty");
    require(price > 0, "Price must be greater than 0");
    require(bytes(courses[courseId].courseId).length == 0, "Course ID already exists");
    
    courses[courseId] = Course({
        courseId: courseId,
        title: title,
        description: description,
        price: price,
        creator: msg.sender,
        isActive: true,
        createdAt: block.timestamp
    });
    
    courseIds.push(courseId);
    emit CourseCreated(courseId, title, price, msg.sender);
}

/**
 * @dev 购买课程
 * 平台将收取5%的手续费，剩余95%支付给课程创建者
 */
function purchaseCourse(string memory courseId) external nonReentrant {
    require(bytes(courses[courseId].courseId).length > 0, "Course does not exist");
    require(courses[courseId].isActive, "Course is not active");
    require(!userCoursePurchases[courseId][msg.sender], "Already purchased");
    require(courses[courseId].creator != msg.sender, "Cannot buy your own course");
    
    Course memory course = courses[courseId];
    
    // 计算手续费和创建者收益
    uint256 feeAmount = (course.price * FEE_RATE) / 10000;  // 5%手续费
    uint256 creatorAmount = course.price - feeAmount;        // 95%给创建者
    
    // 向创建者支付代币
    require(
        ydToken.transferFrom(msg.sender, course.creator, creatorAmount),
        "Creator payment failed"
    );
    
    // 平台手续费转入合约
    require(
        ydToken.transferFrom(msg.sender, address(this), feeAmount),
        "Fee transfer failed"
    );
    
    // 记录用户已购买此课程
    userCoursePurchases[courseId][msg.sender] = true;
    
    emit CoursePurchased(courseId, msg.sender, course.price);
    emit FeeCollected(courseId, msg.sender, feeAmount);
}
```

### 代币兑换功能

```solidity
/**
 * @dev 使用ETH购买YD代币
 * 汇率：1 ETH = 4000 YD代币
 */
function buyTokens() external payable nonReentrant {
    require(msg.value > 0, "Must send ETH to buy tokens");
    require(tokenReserve > 0, "Token reserve not initialized");
    
    // 按固定汇率计算可购买的代币数量
    uint256 tokenAmount = msg.value * EXCHANGE_RATE;
    
    require(tokenAmount % 1e18 == 0, "Token amount must be divisible by 1e18");
    require(tokenReserve >= tokenAmount, "Insufficient token reserve");
    
    // 更新储备
    ethReserve += msg.value;     // 增加ETH储备
    tokenReserve -= tokenAmount; // 减少代币储备
    
    // 向购买者转移代币
    ydToken.safeTransfer(msg.sender, tokenAmount);
    
    emit TokensPurchased(msg.sender, msg.value, tokenAmount);
}

/**
 * @dev 出售YD代币获取ETH
 * 汇率：4000 YD代币 = 1 ETH
 */
function sellTokens(uint256 tokenAmount) external nonReentrant {
    require(tokenAmount > 0, "Token amount must be greater than 0");
    require(tokenAmount % EXCHANGE_RATE == 0, "Token amount must be divisible by exchange rate");
    
    // 按固定汇率计算可获得的ETH数量
    uint256 ethAmount = tokenAmount / EXCHANGE_RATE;
    require(ethReserve >= ethAmount, "Insufficient ETH reserve");
    
    // 从卖家转移代币到合约
    ydToken.safeTransferFrom(msg.sender, address(this), tokenAmount);
    
    // 更新储备
    ethReserve -= ethAmount;      // 减少ETH储备
    tokenReserve += tokenAmount;  // 增加代币储备
    
    // 向卖家转移ETH
    payable(msg.sender).transfer(ethAmount);
    
    emit TokensSold(msg.sender, tokenAmount, ethAmount);
}
```

### 关键特性
- **课程生命周期管理**: 支持课程创建、更新、激活/停用
- **收费机制**: 自动处理平台5%手续费和创建者95%收益分配
- **固定汇率兑换**: ETH与YD代币之间的1:4000固定汇率兑换
- **流动性管理**: 维护ETH和代币储备池，支持双向兑换
- **访问控制**: 合约所有者可以管理储备和提取资金

---

## 3. StakingSystem - 基于AAVE的质押收益系统

### 合约功能
这是一个创新的质押系统，将用户的USDT和LINK代币存入AAVE协议获取收益。

### 核心数据结构

```solidity
// USDT质押用户信息结构体
struct UserInfo {
    uint256 stakedAmount;        // 用户原始质押USDT数量
    uint256 aTokenBalance;       // 从AAVE获得的aUSDT代币数量
    uint256 lastStakeTime;       // 最近一次质押时间戳
    uint256 totalRewardsClaimed; // 用户已累计提取的收益
}

// LINK质押用户信息结构体
struct UserLinkInfo {
    uint256 stakedAmount;        // 用户原始质押LINK数量
    uint256 aTokenBalance;       // 从AAVE获得的aLINK代币数量
    uint256 lastStakeTime;       // 最近一次质押时间戳
    uint256 totalRewardsClaimed; // 用户已累计提取的收益
}
```

### AAVE接口集成

```solidity
// AAVE V3 核心接口定义
interface IPool {
    // 向AAVE存入资产
    function supply(
        address asset,       // 要存入的资产地址
        uint256 amount,      // 存入数量
        address onBehalfOf,  // 代表存入的地址
        uint16 referralCode  // 推荐码
    ) external;
    
    // 从AAVE提取资产
    function withdraw(
        address asset,  // 要提取的资产地址
        uint256 amount, // 提取数量
        address to      // 接收地址
    ) external returns (uint256);
}
```

### 质押核心功能

```solidity
/**
 * @dev 质押USDT到AAVE协议获取收益
 * 流程：用户USDT -> 合约 -> AAVE协议 -> 获得aUSDT代币
 * aUSDT代币会随时间自动增值，实现收益的自动复利
 */
function stake(uint256 usdtAmount) 
    external 
    nonReentrant 
    whenNotPaused 
    validAmount(usdtAmount) 
{
    // 从用户转移USDT到合约
    IERC20(USDT_TOKEN).safeTransferFrom(msg.sender, address(this), usdtAmount);
    
    // 将USDT存入AAVE并获得aToken
    uint256 aTokenBalanceBefore = IAToken(aUsdtToken).balanceOf(address(this));
    IPool(aavePool).supply(USDT_TOKEN, usdtAmount, address(this), 0);
    uint256 aTokenBalanceAfter = IAToken(aUsdtToken).balanceOf(address(this));
    uint256 aTokensReceived = aTokenBalanceAfter - aTokenBalanceBefore;
    
    // 更新用户信息
    UserInfo storage user = userInfo[msg.sender];
    user.stakedAmount += usdtAmount;      // 累加质押量
    user.aTokenBalance += aTokensReceived; // 累加aToken余额
    user.lastStakeTime = block.timestamp;  // 更新质押时间
    
    // 更新系统统计
    totalStaked += usdtAmount;
    
    emit Staked(msg.sender, usdtAmount, aTokensReceived);
}
```

### 收益提取机制

```solidity
/**
 * @dev 计算用户未提取的收益
 */
function _calculateUserRewards(address userAddr) internal view returns (uint256) {
    UserInfo storage user = userInfo[userAddr];
    if (user.aTokenBalance == 0 || user.stakedAmount == 0) return 0;
    
    // 当前aToken的价值（随时间增长）
    uint256 currentATokenValue = user.aTokenBalance;
    
    // 基础收益 = 当前aToken价值 - 原始质押量 - 已提取收益
    if (currentATokenValue > user.stakedAmount + user.totalRewardsClaimed) {
        return currentATokenValue - user.stakedAmount - user.totalRewardsClaimed;
    }
    
    return 0;
}

/**
 * @dev 提取AAVE收益
 */
function claimRewards() external nonReentrant {
    UserInfo storage user = userInfo[msg.sender];
    require(user.aTokenBalance > 0, "No staked amount");
    
    // 计算用户的未提取收益
    uint256 userRewards = _calculateUserRewards(msg.sender);
    require(userRewards > 0, "No rewards available");
    
    // 从AAVE提取收益
    uint256 withdrawnAmount = IPool(aavePool).withdraw(
        USDT_TOKEN,
        userRewards,
        address(this)
    );
    
    // 更新用户的收益追踪
    user.totalRewardsClaimed += withdrawnAmount;
    totalRewardsPaid += withdrawnAmount;
    
    // 转移收益给用户
    IERC20(USDT_TOKEN).safeTransfer(msg.sender, withdrawnAmount);
    
    emit RewardsClaimed(msg.sender, withdrawnAmount);
}
```

### 关键特性
- **AAVE集成**: 直接与AAVE V3协议交互，享受DeFi生态的成熟收益
- **aToken机制**: 通过持有aToken实现收益的自动复利增长
- **双代币支持**: 同时支持USDT和LINK代币质押
- **精确收益跟踪**: 通过aToken余额变化精确计算用户收益
- **灵活提取**: 用户可以随时提取本金和收益
- **安全保障**: 集成重入保护、暂停机制和紧急提取功能

---

## 架构总结

### 系统流程图
```
用户钱包
    ↓
1. 购买YD代币 (CourseManager.buyTokens)
    ↓
2. 购买课程 (CourseManager.purchaseCourse)
    ↓
3. 质押USDT/LINK获取收益 (StakingSystem.stake)
    ↓
4. 从AAVE获取质押收益 (StakingSystem.claimRewards)
```

### 合约间协作
- **YDToken**: 提供平台代币基础设施
- **CourseManager**: 使用YDToken进行课程交易，提供ETH兑换服务
- **StakingSystem**: 独立的收益系统，与外部AAVE协议集成

### 技术亮点
1. **模块化设计**: 三个合约职责清晰，便于维护和升级
2. **DeFi集成**: 与AAVE协议深度集成，提供真实的链上收益
3. **安全机制**: 全面的重入保护、权限控制和紧急处理机制
4. **用户友好**: 简化的交互流程，自动化的收益分配

这套合约系统构建了一个完整的Web3教育平台生态，结合了代币经济、课程交易和DeFi收益，为用户提供了丰富的价值创造和获取途径。